/* ------------------------------------------------------------------------------
 * Copyright (c) 2006 Novell, Inc. All Rights Reserved.
 *
 *
 * This program is free software; you can redistribute it and/or modify it under
 * the terms of version 2 of the GNU General Public License as published by the
 * Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along with
 * this program; if not, contact Novell, Inc.
 *
 * To contact Novell about this file by physical or electronic mail, you may find
 * current contact information at www.novell.com.
 * ------------------------------------------------------------------------------
 */

/**
 * File:	modules/Snapper.ycp
 * Summary:	Snapper settings, input and output functions
 * Authors:	Jiri Suchomel <jsuchome@suse.cz>
 *
 * $Id$
 *
 * Representation of the configuration of snapper.
 * Input and output routines.
 */

{

module "Snapper";
textdomain "snapper";

import "FileUtils";
import "Label";
import "Progress";
import "Report";


// global list of all snapshot
global list<map> snapshots	= [];

global string snapshots_path	= "/snapshots";

global map selected_snapshot	= $[];

// mapping of snapshot number to index in snapshots list
global map<integer,integer> id2index	= $[];

// index to snapshots list
global integer selected_snapshot_index	= 0;

/**
 * Return map of files modified between given snapshots
 * Return structure has just one level, and maps each modified file to it's modification map
 */
global map<string,string> ReadModifiedFilesIndex (integer from, integer to) {
    return (map<string,string>) SCR::Read (.snapper.diff_index, $[ "from" : from, "to" : to]);
}

/**
 * Return map of files modified between given snapshots
 * Map is recursively describing the filesystem structure; helps to build Tree widget contents
 */
global map<string, map> ReadModifiedFilesMap (integer from, integer to) {
    return (map<string, map>) SCR::Read (.snapper.diff_tree, $[ "from" : from, "to" : to]);
}

/**
 * Describe what was done with given file between given snapshots
 * - when new is 0, meaning is 'current system'
 */
global map GetFileModification (string file, integer old, integer new) {

    map ret	= $[];

    string file1	= sformat ("%1/%2/snapshot%3", snapshots_path, old, file);
    string file2	= sformat ("%1/%2/snapshot%3", snapshots_path, new, file);
    if (new == 0)
	file2	= file;

    y2milestone ("comparing '%1' and '%2'", file1, file2);

    if (FileUtils::Exists (file1) && FileUtils::Exists (file2))
    {
	list<string> status	= [ "no_change" ];
	map out	= (map) SCR::Execute (.target.bash_output,
	    sformat ("/usr/bin/diff -u %1 %2", file1, file2));
	if (out["stderr"]:"" != "")
	{
	    y2warning ("out: %1", out);
	    ret["diff"] = out["stderr"]:"";
	}
	// the file diff
	else if (out["stdout"]:nil != "")
	{
	    status	= ["diff"];
	    ret["diff"]	= out["stdout"]:"";
	}

	// check mode and ownerships
	out = (map) SCR::Execute (.target.bash_output,
	    sformat ("ls -ld %1 %2 | cut -f 1,3,4 -d ' '", file1, file2));
	list<string> parts	= splitstring (out["stdout"]:""," \n");

	if (parts[0]:"" != parts[3]:"")
	{
	    status		= add (status, "mode");
	    ret["mode1"]	= parts[0]:"";
	    ret["mode2"]	= parts[3]:"";
	}
	if (parts[1]:"" != parts[4]:"")
	{
	    status		= add (status, "user");
	    ret["user1"]	= parts[1]:"";
	    ret["user2"]	= parts[4]:"";
	}
	if (parts[2]:"" != parts[5]:"")
	{
	    status		= add (status, "group");
	    ret["group1"]	= parts[2]:"";
	    ret["group2"]	= parts[5]:"";
	}
	ret["status"]	= status;
    }
    else if (FileUtils::Exists (file1))
    {
	ret["status"]	= ["removed"];
    }
    else if (FileUtils::Exists (file2))
    {
	ret["status"]	= ["created"];
    }
    else
    {
	ret["status"]	= ["none"];
    }
    return ret;
}

/**
 * Read the list of snapshots
 */
global boolean ReadSnapshots () {


    list<map> snapshot_maps	= (list<map>) SCR::Read (.snapper.snapshots);
    if (snapshot_maps == nil) snapshot_maps = [];
    integer i	= 0;
    foreach (map snapshot, snapshot_maps, {
	integer id	= snapshot["num"]:0;
	if (id == 0) return; // ignore the 'current system'
	snapshot["name"]	= tostring (id);
	y2debug ("snapshot data: %1", snapshot);
	snapshots	= add (snapshots, snapshot);
	id2index[id]	= i;
	i		= i + 1;
    });


    return true;
}

global map LastSnapperErrorMap () {

    return (map) SCR::Read (.snapper.error);
}

/**
 * Initialize snapper agent
 * Return true on success
 */
global boolean InitializeSnapper () {

    boolean init	= (boolean) SCR::Execute (.snapper);
    if (!init)
    {
	map err_map	= LastSnapperErrorMap ();
	string type	= err_map["type"]:"";
	string details	= _("Reason not known.");
	if (type == "config_not_found")
	{
	    details	= _("Configuration not found.");
	}
	else if (type == "config_invalid")
	{
	    details	= _("Configuration is not valid.");
	}

	y2warning ("init failed with '%1'", err_map);
	// error popup
	Report::Error (sformat (_("Failed to initialize snapper library:
%1"), details));
    }
    return init;

}

/**
 * Read all snapper settings
 * @return true on success
 */
global boolean Read() {

    /* Snapper read dialog caption */
    string caption = _("Initializing Snapper");

    integer steps = 2;

    // We do not set help text here, because it was set outside
    Progress::New( caption, " ", steps, [
	    /* Progress stage 1/3 */
	    _("Read the list of snapshots"),
	], [
	    /* Progress step 1/3 */
	    _("Reading the database..."),
	    /* Progress finished */
	    _("Finished")
	],
	""
    );

    Progress::NextStage();

    if (!InitializeSnapper ())
    {
	return false;
    }

    ReadSnapshots ();

    Progress::NextStage();
    return true;
}

/**
 * Return the given file mode as octal number
 */
integer GetFileMode (string file) {

    map out = (map) SCR::Execute (.target.bash_output, "/bin/stat --printf=%a " + file);
    return tointeger (out["stdout"]:"755");
}

/**
 * Copy given files from selected snapshot to current filesystem
 * @param snapshot_num snapshot identifier
 * @param files list of full paths to files
 * @return success
 */
global boolean RestoreFiles (integer snapshot_num, list<string> files) {

    boolean ret	= true;
    y2milestone ("going to restore files %1", files);

    UI::OpenDialog (`opt (`decorated), `HBox (`HSpacing(1.5), `VBox (
	`HSpacing (60),
	// label for log window
	`LogView (`id (`log), _("Restoring Files..."), 8, 0),
	`ProgressBar (`id (`progress), "", size (files), 0),
	`PushButton (`id (`ok), Label::OKButton ())
    ), `HSpacing (1.5)));

    UI::ChangeWidget (`id (`ok), `Enabled, false);
    integer progress	= 0;
    foreach (string file, files, {

	UI::ChangeWidget (`id (`progress ), `Value, progress);

	string orig	= sformat ("%1/%2/snapshot", snapshots_path, snapshot_num) + file;

	string dir	= substring (file, 0, findlastof (file, "/"));
	if (!FileUtils::Exists (orig))
	{
	    // log entry (%1 is file name)
	    UI::ChangeWidget (`id (`log), `LastLine, sformat (_("%1 does not exist in snapshot %2\n"), file, snapshot_num));
	}
	else if (FileUtils::CheckAndCreatePath (dir))
	{
	    y2milestone ("copying '%1' to '%2' (dir: %3)", orig, file, dir);
	    if (FileUtils::IsDirectory (orig) == true)
	    {
		map stat	= (map) SCR::Read (.target.stat, orig);
		if (!FileUtils::Exists (file))
		{
		    SCR::Execute (.target.mkdir, file);
		}
		SCR::Execute (.target.bash, sformat ("/bin/chown %1:%2 '%3'", stat["uid"]:0, stat["gid"]:0, file));
		SCR::Execute (.target.bash, sformat ("/bin/chmod %1 '%2'", GetFileMode (orig), file));
	    }
	    else
	    {
		SCR::Execute (.target.bash, sformat ("/bin/cp -a '%1' '%2'", orig, file));
	    }
	    UI::ChangeWidget (`id (`log), `LastLine, file + "\n");
	}
	else
	{
	    y2milestone ("failed to copy file '%1' to '%2' (dir: %3)", orig, file, dir);
	    // log entry (%1 is file name)
	    UI::ChangeWidget (`id (`log), `LastLine, sformat (_("%1 skipped\n"), file));
	}
	sleep (100);
	progress        = progress + 1;
    });

    UI::ChangeWidget (`id (`progress ), `Value, progress);
    UI::ChangeWidget (`id (`ok), `Enabled, true);

    UI::UserInput ();
    UI::CloseDialog ();

    return ret;
}


/* EOF */
}
